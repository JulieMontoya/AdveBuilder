\  ADVEBUILDER GAME ENGINE
\  NOW WITH EXAMINE MESSAGE EMBEDDED IN OBJECT
\
\  THIS IMPLEMENTS MOVING FROM ROOM TO ROOM, COLLECTING AND
\  EXAMINING OBJECTS, SAVING AND RESTORING
\
\  YOU JUST NEED TO ADD THE PUZZLE LOGIC IN BASIC!

\  VARIABLES

stream_ptr = &70        \  pointer to byte in stream
stream_bit = &72        \  bit within byte in stream
tree_pos   = &73        \  current position on tree
bits_read  = &73        \  also used for extracted bits
caps_flag  = &74        \  capitalisation flag
tempA      = &75        \  temporary store for A
scr_width  = &76        \  width of text on screen so far
wbuf_ptr   = &77        \  pointer in word buffer
temp_obj   = &78

cmd_ptr    = &7A        \ pointer to command buffer
word_ptr   = &7C        \ pointer to words
tempX      = &7E
tempY      = &7F

place_val  = &80
digits     = &81
show_desc  = &82
obj_count  = &83
uio_count  = &84

list_ptr   = &86

wordbuf    = &9C0       \  word buffer

LWIDTH     = 40         \  line width
LIGHT_SRC  = 9          \  light source

bas_var_D = &410        \  BASIC variable D% = destination
bas_var_E = &414        \  BASIC variable E% = error
bas_var_I = &424        \  BASIC variable I% = index of word
bas_var_K = &42C        \  BASIC variable K% = light status of dest room
bas_var_L = &430        \  BASIC variable L% = light status
bas_var_M = &434    	\  BASIC variable M% = modifier
bas_var_N = &438    	\  BASIC variable N% = noun
bas_var_R = &448        \  BASIC variable R% = room
bas_var_V = &458    	\  BASIC variable V% = verb

cmdbuf = &900

game_data = &3D00

osfile = &FFDD          \  = *SAVE / *LOAD
osasci = &FFE3      	\  display character
osnewl = &FFE7          \  new line
osword = &FFF1          \  = INPUT

INCLUDE "stock_messages.6502"

GUARD &6000             \  Don't let anything stray into screen memory

\  ORG IS EQUIVALENT TO SETTING P%, ON A REAL BEEBr
ORG &5500

._code_begin

\  PARSE A COMMAND
\
\  On exit, BASIC variables will be set as follows:
\    V% => the first word (verb)
\    M% => the second word (modifier)
\    N% => the last word (noun) (may be same as M%)
\    I% => index in memory of last word

.parse_cmd
    JSR reset_cmd_buffer
    LDA #0
    STA bas_var_V
    STA bas_var_M
    STA bas_var_N
    
    JSR skip_spaces
    BCS _pc_end
    
    \ now we should be at the first word

._pc_verb    
    JSR match_verb
    BCS _pc_end
    AND #&7F
    STA bas_var_V       \  save first word
    
    JSR adv_cmd_ptr_Y
    JSR skip_spaces
    BCS _pc_end
    
    LDA bas_var_V
    BEQ _pc_verb

    \ now we should be at the second word
    
    JSR match_noun
    BCS _pc_end
    AND #&7F
    STA bas_var_M       \  save second word .....
    STA bas_var_N       \  ..... which is also last word

    \  Now just keep parsing words
    
._pc_last_word
    JSR adv_cmd_ptr_Y
    JSR skip_spaces
    BCS _pc_end
    LDA (cmd_ptr), Y
    CMP #13
    BEQ _pc_end
    
    \ If we hit this point, that was a real word

    JSR match_noun
    BCS _pc_end
    AND #&7F
    STA bas_var_N       \  save last (so far) word
    BCC _pc_last_word
    
._pc_end
    RTS
._pc_clc
    CLC
    RTS

.match_noun
    LDY #&F6            \  noun_list
    JSR init_list_ptr
    BNE _mw0
.match_verb
    LDY #&F4            \  verb_list
    JSR init_list_ptr
._mw0
    LDY #0    
._mw1
    LDA cmd_ptr
    STA bas_var_I
    LDA cmd_ptr+1
    STA bas_var_I+1
    LDA (list_ptr), Y
    BEQ _mw_end
    BMI _mw3
._mw2
    JSR adv_list_ptr
    BNE _mw1            \  either BNE succeeded, or INC gave
                        \  high byte of an address in RAM
\  HERE WE HAVE A WORD NUMBER AT (list_ptr), Y
._mw3
    TAX                 \  save the maybe-matched word number
    JSR adv_list_ptr
    LDA (cmd_ptr), Y    \  first char of word in buffer
    CMP (list_ptr), Y   \  see if it matched
    BNE _mw_miss
\  HERE WE HAVE MATCHED THE FIRST BYTE OF A WORD
._mw4
    INY
    LDA (cmd_ptr), Y
    CMP #33             \  C=0 => end of cmd word
    BCC _mw5
    CMP (list_ptr), Y
    BEQ _mw4            \  keep going as long as it matches
\  HERE WE FAILED TO MATCH A CHARACTER
._mw_miss
    LDY #0
    BEQ _mw2
\  HERE WE RAN OUT OF LETTERS IN THE COMMAND WORD
\  WHICH MEANS WE HAVE A MATCH!
._mw5
    TXA
    CLC
    RTS
._mw_end
    SEC
    RTS

\  ADVANCE THE WORD LIST POINTER

.adv_list_ptr
    INC list_ptr        \  increase the low byte
    BNE _awp1           \  done, if it did not roll over
    INC list_ptr+1      \  increase the high byte
._awp1
    RTS                 \  NB. here Z=0 for sure

\  SKIP SPACES IN COMMAND

.skip_spaces

._ssc0
    LDY #0
._ssc1
    LDA (cmd_ptr), Y
    CMP #33
    BCS _ssc4
    CMP #13
    BEQ _ssc3
    INY
    BNE _ssc1
._ssc2
    LDA #0
._ssc3
    SEC
    RTS
._ssc4

\  FALL THROUGH

\  ADVANCE THE COMMAND POINTER BY Y

.adv_cmd_ptr_Y
    TYA
    CLC
    ADC cmd_ptr
    STA cmd_ptr
    BCC _acp1
    INC cmd_ptr+1
._acp1
    LDY #0
    RTS

.reset_cmd_buffer
    LDA # cmdbuf MOD256
    STA cmd_ptr
    LDA # cmdbuf DIV256
    STA cmd_ptr+1
    RTS
    
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\
\  GET A COMMAND

.real_get_cmd
    LDA #0              \  clear error
    STA bas_var_E
    LDA bas_var_R
    JSR set_visited
    LDA #58
    JSR osasci
    LDX #input_cblk MOD256
    LDY #input_cblk DIV256
    LDA #0
    JSR osword
    
    JSR parse_cmd

\  TEST THE COMMAND
\
\  IF THE COMMAND IS A BUILT-IN ONE, WE TEST ITS FEASIBILITY HERE AND
\  MAYBE SET bas_var_E TO INDICATE AN ERROR IF NECESSARY, BUT WE ARE
\  NOT DISPLAYING ANYTHING YET.
\
\  AS SOON AS WE HAVE SORTED OUT THE EFFECT, WE DROP BACK TO BASIC.

.test_cmd
    LDX bas_var_V
    BEQ _tc_null
    CPX #11
    BCS _tc_not_dir
    LDA exits-1,X
._tc_dir1
    STA bas_var_D       \  stash next room
    JSR sel_rm1         \  see if it is light or dark

\  EVERY ROOM RECORD BEGINS WITH A SINGLE BIT INDICATING WHETHER
\  OR NOT THE ROOM IS ILLUMINATED.  THIS IS IN THE LEFTMOST BIT
\  POSITION, SO WILL AFFECT THE N FLAG; - => LIGHT, + => DARK

    LDA (stream_ptr),Y  \  we already set Y=0
    BPL _tc_next_dk     \  branch if leftmost bit = 0
    LDA #1
    BNE _tc_next_lt1
._tc_next_dk
    TYA
._tc_next_lt1
    STA bas_var_K
    LDA bas_var_D       \  retrieve next room
    BNE _tc_exitok
._tc_noexit
    LDA #SM_NO_EXIT     \  no exit
    STA bas_var_E
._tc_exitok
    RTS
    
._tc_null
    LDA #SM_NONSENSE    \  nonsense
    STA bas_var_E
    RTS

._tc_not_dir
    CPX #11
    BNE _tc_not_back
._tc_back
    LDA prev_rm
    JMP _tc_dir1

._tc_not_back
    CPX #12
    BNE _tc_not_look
    
._tc_look
    LDA #255
    STA show_desc
    RTS
    
._tc_not_look
    CPX #13
    BNE _tc_not_exam
._tc_exam
    JSR real_test_avail
    BEQ _tc_ex1
    LDA #SM_NOT_HERE    \  not here
    STA bas_var_E
._tc_ex1
    RTS

._tc_not_exam
    CPX #14
    BNE _tc_not_take

._tc_take
    LDX bas_var_N
    BEQ _tc_tk_any
    LDA object_loc,X
    CMP bas_var_R
    BEQ _tc_tk1
._tc_tk_noh
    LDA #SM_NOT_HERE    \  not here
    STA bas_var_E
    RTS
._tc_tk1
    LDA bas_var_N
    JSR select_obj2

\  EVERY OBJECT RECORD BEGINS WITH A SINGLE BIT INDICATING WHETHER
\  OR NOT THE OBJECT CAN BE CARRIED.  THIS IS IN THE LEFTMOST BIT
\  POSITION, SO WILL AFFECT THE N FLAG; - => CAN CARRY, + => CAN'T

    LDA (stream_ptr),Y  \  we already set Y=0
    BMI _tc_tk2
    LDA #SM_CANT_DO     \  can't do
    STA bas_var_E
._tc_tk2
    RTS

\  NO NOUN => TRY TO TAKE NEAREST OBJECT    

._tc_tk_any             \  no noun; try to take nearest object
    STX tempX
._tc_tk3
    LDA object_loc,X    \  see if object is in room
    CMP bas_var_R
    BEQ _tc_tk5
._tc_tk4
    INX
    CPX object_loc      \  one more than count of objects
    BNE _tc_tk3
    BEQ _tc_tk_noh
._tc_tk5                \  object is in room; see if or not it
                        \  can be carried
    STX temp_obj        \  X is about to get overwritten
    TXA
    JSR select_obj2 
    LDA (stream_ptr),Y
    PHP                 \  save N flag
    LDX temp_obj        \  this will stomp on N .....
    PLP                 \  ..... till we restore it
    BPL _tc_tk4         \  move on if can't carry
._tc_tk6
    STX bas_var_N
    RTS
    
._tc_not_take
    CPX #15
    BNE _tc_not_drop

._tc_drop
    LDX bas_var_N
    LDA object_loc,X
    BEQ _tc_dp1
    LDA #SM_NO_CARRY    \  not carrying
    STA bas_var_E
._tc_dp1    
    RTS

._tc_not_drop
    LDY #0
    RTS

\  TEST IF OBJECT N% IS AVAILABLE  (CARRIED OR IN ROOM)
\  on return  Z=0 => OBJECT IS AVAILABLE
\             Z=1 => NEITHER CARRIED NOR IN ROOM

.real_test_avail
    LDX bas_var_N
.real_test_avail_X
    LDA object_loc,X    \  Z=1 => carried
    BEQ _ta1
    CMP bas_var_R       \  Z=1 => in room
._ta1
    RTS

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\
\  ACTION COMMAND
\
\  CHECK FOR DIE and LIVE FIRST; THEY DON'T CARE ABOUT E%.

.real_action_cmd
    LDX bas_var_V
    BEQ _ac_not_live

    CPX #20             \  DIE pseudo-verb
    BNE _ac_not_die
._ac_die
    JSR _ac_live
    LDA #SM_GAME_OVER
    STA bas_var_E
    JMP real_select_sysmsg
    
._ac_not_die
    CPX #21             \  LIVE pseudo-verb
    BNE _ac_not_live
._ac_live
    LDA bas_var_M
    JMP real_select_msg

._ac_not_live

\  CHECK THE STATUS IN E%; ANYTHING BUT 0 INDICATES AN ERROR

    LDA bas_var_E       \  If non-zero, display error message
    BEQ _ac_no_err
    JMP real_select_sysmsg

\  IF E% = 0 THEN ASSUME THE COMMAND IS SAFE TO ACTION

._ac_no_err
    TXA
    BEQ _ac_null
    CPX #12             \  back is a direction too
    BCS _ac_not_dir
._ac_dir
    LDY bas_var_D       \  make sure destination is still valid
    BEQ _ac_noexit
    LDA bas_var_R
    STA prev_rm
    STY bas_var_R
    JMP force_desc

._ac_null
    RTS

._ac_noexit
    LDA #SM_NO_EXIT     \  no exit
    JMP real_select_sysmsg
    
._ac_not_dir
    CPX #12
    BNE _ac_not_look

._ac_look
    LDA #255
    STA show_desc
    RTS

._ac_not_look
    CPX #16             \  INVENTORY
    BEQ real_inventory
    JMP _ac_not_inv

.real_inventory
    LDA #SM_PRE_INV     \  inventory prefix
    JSR real_select_sysmsg
    JSR count_obj
    LDX #1
._inv1
    STX temp_obj
    LDA object_loc,X
    BNE _inv2
    \LDA #32
    \JSR osasci
    JSR space
    JSR osasci
    JSR real_shift_on        \  force capital letter
    LDA temp_obj
    JSR real_obj_short_desc
    JSR osnewl
._inv2
    LDX temp_obj
    INX
    CPX object_loc      \  loc[0] => count+1
    BCC _inv1
    LDA uio_count
    BNE _inv4
    LDA obj_count
    BNE _inv3
    LDA #SM_INV_NONE    \  carrying nothing
    JSR real_select_sysmsg
    JSR osnewl
\    JSR newnewl
._inv3
    RTS
._inv4
    JSR say
    EQUS "  Something picked up in the dark"
    BRK
    LDA uio_count
    CMP #1
    BEQ _inv5
    JSR say
    EQUS " (*"
    BRK
    LDA uio_count
    JSR disp_dec
    LDA #41
    JSR osasci
._inv5
    LDA #46
    JSR osasci
    JMP osnewl

._ac_not_inv
    CPX #13
    BNE _ac_not_exam
._ac_exam
    LDA bas_var_N
    JSR select_obj
    JSR update_obj_state
    LDA obj_em_addr
    STA stream_ptr
    LDA obj_em_addr+1
    STA stream_ptr+1
    JMP disp_msg
    
._ac_not_exam
    CPX #14
    BNE _ac_not_take
._ac_take
    LDA bas_var_L
    BEQ _ac_take1
    LDA #0
    LDX bas_var_N
    STA object_loc,X
    JSR say
    EQUS "You take "
    BRK
    JMP _ac_drop1
._ac_take1
    LDA #255            \  objects picked up in dark go into room 255
    LDX bas_var_N
    STA object_loc,X
    JSR say
    EQUS "You grab the nearest object in the dark."
    BRK
    JMP osnewl
    
._ac_not_take
    CPX #15
    BNE _ac_not_drop
._ac_drop
    LDA bas_var_R
    LDX bas_var_N
    STA object_loc,X
    JSR say
    EQUS "You drop "
    BRK
._ac_drop1
    JSR shift_off
    LDA bas_var_N
    JSR real_obj_short_desc
    LDA #46
    JSR osasci
    JMP osnewl
    
._ac_not_drop
    CPX #17             \  SAVE
    BNE _ac_not_save
._ac_save
    LDA bas_var_R       \  Stash current room .....
    STA object_loc+&7C
    LDA prev_rm         \  ..... and previous room
    STA object_loc+&7D
    JSR setup_osfile
    LDA #0              \  *SAVE
    JSR osfile
    JSR say
    EQUS "Saved position as "
    BRK
    LDY osfile_cb+1
    LDX osfile_cb
    JSR say_XY
    JMP osnewl

._ac_not_save
    CPX #18             \  RESTORE
    BNE _ac_not_restore
._ac_restore
    JSR setup_osfile
    LDA #&FF
    STA show_desc       \  No point wasting this
    JSR osfile
    LDA object_loc+&7C  \  Retrieve room .....
    STA bas_var_R
    LDA object_loc+&7D  \  ..... and previous room
    STA prev_rm
    
._ac_not_restore
    CPX #19             \  RESTART
    BNE _ac_not_restart
._ac_restart
    JMP real_init_game

._ac_not_restart
\    CPX #20             \  DIE pseudo-verb
\    BNE _ac_not_die
\._ac_die
\    JSR _ac_live
\    LDA #10
\    JMP real_select_sysmsg
\    
\._ac_not_die
\    CPX #21             \  LIVE pseudo-verb
\    BNE _ac_not_live
\._ac_live
\    LDA bas_var_M
\    JMP real_select_msg
\
\._ac_not_live
    RTS
    
.setup_osfile
    LDX #15             \  Pristinify OSFILE control block
._su_osf0               \  the crude way, by overwriting
    LDA _cb_addrs,X     \  addresses with a clean copy
    STA osfile_cb+2,X
    DEX
    BPL _su_osf0
    LDA bas_var_I       \  see if a filename was supplied
    BEQ _su_osf1
    STA osfile_cb
    LDA bas_var_I+1     \  we know this is not 0
    BNE _su_osf2
._su_osf1
    LDA #_def_fn MOD256 \  pointer to default filename
    STA osfile_cb
    LDA #_def_fn DIV256
._su_osf2
    STA osfile_cb+1    
    LDY #osfile_cb DIV256
    LDX #osfile_cb MOD256
    RTS

\  DISPLAY SHORT ("CARRIED") DESCRIPTION OF AN OBJECT

.real_obj_short_desc
    JSR select_obj
    JSR update_obj_state
    LDA obj_sd_addr
    STA stream_ptr
    LDA obj_sd_addr+1
    STA stream_ptr+1
    JMP disp_msg

\  DISPLAY LONG ("IN_ROOM") DESCRIPTION OF AN OBJECT

.obj_long_desc
    JSR select_obj
    JSR update_obj_state
    LDA obj_ld_addr
    STA stream_ptr
    LDA obj_ld_addr+1
    STA stream_ptr+1
    JMP disp_msg

\  COUNT OBJECTS CARRIED. 

.count_obj
    LDX #0
    STX obj_count
    STX uio_count
    INX                 \  start with object 1
._co1
    LDA object_loc,X
    BEQ _co4            \  room 0 => carrying
    CMP #255            \  room 255 => picked up in dark
    BNE _co5    
._co2
    LDA bas_var_L
    BNE _co3
    INC uio_count
    BNE _co5            \  expect always to branch
._co3                   \  we know what it is now
    LDA #0              \  move it to plain carrying
    STA object_loc,X
._co4
    INC obj_count
._co5
    INX
    CPX object_loc      \  loc[0] => total objects + 1
    BCC _co1
    RTS
    
\  READ A BIT WITHIN THE GAME STATE BITS

.real_get_state_bit
    JSR get_bit_offset
    LDA state_bits, Y
    AND bits_LR, X
    RTS

\  CLEAR A GAME STATE BIT, BY SETTING IT AND THEN FLIPPING IT

.real_clear_state_bit
    JSR real_set_state_bit
    EOR bits_LR, X
    STA state_bits, Y
    RTS

\  SET A GAME STATE BIT

.real_set_state_bit
    JSR get_bit_offset
    LDA state_bits, Y
    ORA bits_LR, X
    STA state_bits, Y
    RTS

\  GET THE VISITED STATE OF A ROOM

.real_get_visited
\     LDA bas_var_R
\ .real_get_visited0
    JSR get_bit_offset
    LDA visited_bits, Y
    AND bits_LR, X
    RTS

.clear_visited
    JSR set_visited
    ORA bits_LR, X
    STA visited_bits, Y
    RTS

.set_visited
    JSR get_bit_offset
    LDA visited_bits, Y
    ORA bits_LR, X
    STA visited_bits, Y
    RTS
    
\  ON ENTRY;
\  A => INDEX TO BIT
\  ON RETURN;
\  Y => INDEX TO BYTE
\  X => INDEX TO BIT WITHIN BYTE

.get_bit_offset
    PHA
    AND #7
    TAX
    PLA
    LSR A
    LSR A
    LSR A
    TAY
    RTS

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\
\  HANDLE ARTIFICIAL LIGHT
\
\  IF THE LIGHT SOURCE IS ACTIVATED, AND EITHER CARRIED OR IN THE
\  ROOM WITH THE PLAYER, TREAT THE ROOM AS THOUGH IT WERE LIGHT

.real_art_light
    LDA #LIGHT_SRC      \  check state of light source
    JSR real_get_state_bit
    BEQ _al_dark
.art_light1
    LDX #LIGHT_SRC
    LDA object_loc,X
    BEQ _al_light       \  branch if carrying light source
    CMP bas_var_R
    BNE _al_dark        \  branch if light source not in room
._al_light
    LDA #1
    STA bas_var_L
._al_dark
    RTS

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\
\  DISPLAY ROOM DESCRIPTION

.real_disp_desc
    LDA show_desc
    BEQ _dd_no_desc
    JSR real_shift_on        \  force capital letter
    LDA bas_var_L
    BEQ _dd_dark
    JSR count_obj
    LDA room_desc_addr+1
    STA stream_ptr+1
    LDA room_desc_addr
    STA stream_ptr
    JMP disp_msg
._dd_no_desc
    RTS
._dd_dark
    LDA #SM_DARK        \  dark
    JMP real_select_sysmsg

\  LIST ALL AVAILABLE DIRECTIONS
\  THIS MAY NOT BE REQUIRED, IF ROOM DESCRIPTIONS INCLUDE MENTION OF
\  AVAILABLE EXITS, BUT WE ARE COVERING ALL BASES.
\
\  DIRECTIONS ARE DISPLAYED WITH A COMMA BETWEEN THEM AND AN "AND"
\  SIGN BEFORE THE LAST;  North, East & West

.get_exits
    LDX #0
    STX tempX
    STX tempY
    INX
._gx1
    LDA exits-1,X
    BEQ _gx2
    STX tempX
._gx2
    INX
    CPX #11
    BCC _gx1
    
    \  Now tempX contains last available exit
    
    LDX #1
._gx3
    LDA exits-1,X
    BNE _gx4
    INX
    CPX #11
    BCC _gx3
    JSR say
    EQUS "  Just BACK."
    BRK
    JMP osnewl          \  Nothing to display
._gx4
    STX tempY
    
    \  Now tempY contains first available exit
    
    NOP
    \ RTS
    
.show_exits
    LDX #1
    LDY #0
._sx1
    LDA direction_list,Y
    BNE _sx4            \  if not CHR$(0), maybe print a character
    CPX tempX           \  see if that was the last available direction
    BCC _sx1a           \  carry on if not .....
    JMP osnewl          \  ..... or start a new line and exit
._sx1a
    INX                 \  if is CHR$(0) move on to next direction
    CPX tempY           \  see if is first available direction
    BEQ _sx3            \  ..... which does not need a comma
    CPX tempX           \  see if is last available direction
    BNE _sx2
    \LDA #32            \  space
    \JSR osasci
    JSR space
    LDA #38             \  and sign
    JMP _sx2a
._sx2
    LDA exits-1,X       \  skip comma if exit not available
    BEQ _sx3
    LDA #44
._sx2a
    JSR osasci
._sx3
    INY
    BNE _sx1            \  go round the loop again
    
._sx4
    LDA exits-1,X
    BEQ _sx5            \  skip printing if exit not available
    LDA direction_list,Y
    JSR osasci
._sx5
    INY
    BNE _sx1
    \  We should never, ever get here
    RTS

\  NAMES OF DIRECTIONS IN ORDER.
\  NOTE EACH ONE HAS A SPACE BEFORE AND A BRK AFTERWARDS.

.direction_list
    EQUS " North": BRK
    EQUS " Northeast": BRK
    EQUS " East": BRK
    EQUS " Southeast": BRK
    EQUS " South": BRK
    EQUS " Southwest": BRK
    EQUS " West": BRK
    EQUS " Northwest": BRK
    EQUS " Up": BRK
    EQUS " Down": BRK
    
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\  DISPLAY A SINGLE BYTE UNSIGNED DECIMAL NUMBER WITHOUT LEADING ZEROS

.disp_dec
    LDX #0
    STX digits
    LDX #100
    JSR _dd_get_digit   \  return with 100s in A, rest in Y
    BEQ _dd_get10s      \  skip display if no hundreds
    JSR _dd_write_digit
._dd_get10s
    TYA                 \  this is the remainder modulo 100
    LDX #10
    JSR _dd_get_digit
    BNE _dd_show10s     \  always show tens if not 0
    LDX digits          \  don't display 0 if no hundreds
    BEQ _dd_get1s
._dd_show10s
    JSR _dd_write_digit
._dd_get1s
    TYA                 \  this is the remainder modulo 10
._dd_write_digit        \  we always display the units
    CLC
    ADC #48
    JSR osasci
    INC digits
    RTS
._dd_get_digit
    STX place_val
    LDX #0
._dd_try_sub
    TAY
    SEC
    SBC place_val
    BCC _dd_sub_fail
    INX
    BNE _dd_try_sub     \  should never fall through
._dd_sub_fail
    TXA                 \  this is the digit
    RTS
    
.real_list_objects
    LDA show_desc
    BEQ _lo3
    LDA bas_var_L
    BEQ _lo3
    LDX #1
._lo1
    STX temp_obj
    LDA object_loc,X
    CMP bas_var_R
    BNE _lo2
    LDA temp_obj
    JSR obj_long_desc
._lo2
    LDX temp_obj
    INX
    CPX object_loc      \  holds count of objects + 1
    BCC _lo1
._lo3
    RTS

\  INITIALISE THE GAME
\
\  START BY ZEROING OUT ALL THE STATE BITS, VISITED BITS AND STATE
\  BYTE REGISTERS .....

.real_init_game
    LDA #0
    TAX    
._ig1
    STA state_bits,X
    INX
    BPL _ig1

\  ..... NOW WE NEED TO START OBJECTS OFF IN THEIR INITIAL LOCATIONS.
\
\  THERE IS NO OBJECT #0, SO WE USE POSITION 0 IN THE OBJECTS TABLE TO
\  STORE A LIST OF THE INITIAL LOCATIONS OF EACH OBJECT.
\  THE ENTRY AT POSITION 0 IN THIS LIST IS USED FOR NO. OF OBJECTS + 1
\  (ADDING 1 SIMPLIFIES THE LOOP BUSTING TEST).

    LDY #&FE            \  obj_table; A=0 still, this points to init_loc
    JSR init_strm_ptr
    LDY #0              \  [init_loc] => count of objects + 1
._ig2
    LDA (stream_ptr), Y
    STA object_loc, Y
    INY
    CPY object_loc      \  see why we begin the list with its length? ;)
    BCC _ig2
    LDA #1              \  player starts in room #1
    STA bas_var_R
    LDA #SM_WELCOME     \  "welcome" message
    JSR real_select_sysmsg
.force_desc
    LDA #255
    STA show_desc       \  Force description
    JMP osnewl

.input_cblk             \  control block for OSWORD &00
    EQUW cmdbuf         \  input buffer address  (2 bytes)
    EQUB &7F            \  max length
    EQUB 32             \  minimum ASCII code
    EQUB 126            \  maximum ASCII code

\  INITIALISE STREAM POINTER FROM AN ADDRESS IN A TABLE
\
\  Y => index into table of tables  (even no.!)
\  A => index within table

.init_strm_ptr
    LDX #stream_ptr

\  INITIALISE ZERO PAGE POINTER FROM AN ADDRESS IN A TABLE
\  Y => index into table of tables (must be an even number)
\  A => index into table pointed to by Y (will be doubled,
\        and any overflow accounted for)
\  X => pointer in zero page to be initialised
\
\  ON RETURN, THE POINTER AT [X, X+1] CONTAINS THE ADDRESS POINTED TO
\  BY THE A'TH ENTRY IN THE TABLE AT OFFSET Y.
\
\  OFFSETS ARE GIVEN RELATIVE TO tables0, WHICH IS THE FIRST BYTE (&xx00)
\  IN THE LAST PAGE OF THE GAME DATA.
\
\    &F4 => verbs
\    &F6 => nouns and modifiers
\    &F8 => game messages
\    &FA => stock messages
\    &FC => rooms
\    &FE => objects

.init_ptr
    STA tempY
    JSR init_list_ptr
    LDY #0
    LDA tempY
    ASL A               \  here C=1 if A was >= 128
    TAY                 \  now Y is 2 * what A used to be MOD 256
    BCC _ip1            \  see if or not we need to .....
    INC list_ptr+1      \    ..... add 256 to list_ptr
._ip1    
    LDA (list_ptr),Y
    STA 0,X
    INY
    LDA (list_ptr),Y
    STA 1,X
    RTS                 \  with Z=0

\  INITIALISE LIST POINTER TO POINT TO THE BEGINNING OF A TABLE
\  THIS IS USED BOTH FOR STRAIGHTFORWARD LINEAR SEARCHES, AS IN THE WORD
\  LISTS, AND DOUBLE-INDIRECTION TO AN ENTRY WITHIN A LIST SELECTED FROM
\  A LIST OF LISTS.

.init_list_ptr
    LDA tree,Y
    STA list_ptr
    LDA tree+1,Y
    STA list_ptr+1
    RTS

ALIGN &100

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\
\  GAME STATE AREA

.state_bits             \  B0-B255
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0

.visited_bits           \  V0-V255
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0

.state_bytes            \  C0-C63
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0
    
.object_loc             \  L0-L127
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0
    EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0: EQUD 0


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\  SELECT AND DISPLAY A MESSAGE
\  A => MESSAGE INDEX

.real_select_msg
    LDY #&F8            \ msg_table
    JSR init_strm_ptr   \ we know Z=0 here
    BNE disp_msg
.real_select_sysmsg
    LDY #&FA            \ smsg_table
    JSR init_strm_ptr
.disp_msg
    LDA #0
    STA stream_bit
.disp_msg1
    JSR disp_char
    CMP #32
    BCS disp_msg1
.end_of_msg
    RTS

\  DISPLAY A CHARACTER FROM THE STREAM

.disp_char
    JSR reset_tree_pos
    \  now we are at the root of the tree
.dc1
    \  Get a bit from the stream and update current node
    JSR descend_tree
    \  A still contains position on tree
    BIT bits_LR+7   \ check lowest bit
    BEQ dc1         \ keep going until it's set
    LSR A
    \ JMP osasci
    JMP maybe_auto_cap

\  GET A BIT FROM THE STREAM AND UPDATE POSITION ON
\  TREE ACCORDINGLY: BRANCH LEFT ON 0, RIGHT ON 1
\  NB! EXPECTS Y=0

.descend_tree
    JSR get_one_bit
    BEQ _desc_left
._desc_right
    LDA tree+1,X \ its right child
    STA tree_pos
    RTS
._desc_left
    LDA tree,X   \ its left child
    STA tree_pos

._rts
    RTS
    
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\  DISPLAY A CHARACTER, AND POSSIBLY CAPITALISE IT

.maybe_auto_cap
    BIT bits_LR+1       \  check bit 6
    BEQ _ac_is_punct
    BIT bits_LR + 2     \  check bit 5
    BEQ _ac_is_cap
    \  must be a lower-case letter
    BIT caps_flag
    BPL _ac_is_punct    \  skip if clear
    AND #&DF            \  clear bit 5
._ac_is_cap
    PHA
    LDA #0
._ac_set_cap
    STA caps_flag
    PLA
._ac_not_eos
    JMP osasci
._ac_is_punct
    CMP #46             \  full stop
    BEQ _ac_is_eos
    CMP #63             \  question mark
    BEQ _ac_is_eos
    CMP #33             \  exclamation mark
    BNE _ac_not_eos
._ac_is_eos             \  end-of-sentence char
    PHA
    LDA #255
    BNE _ac_set_cap     \  will always branch

.shift_off
    LDA #0
    BEQ _so0
.real_shift_on
    LDA #255
._so0
    STA caps_flag
    RTS

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\  SELECT A ROOM AND UNPACK ITS DATA
\  ON RETURN, bas_var_R [=R%] => current room
\             bas_var_L [=L%] => light status
\             exits           => exit destinations (10 bytes)

.real_select_room
    LDA bas_var_R
    JSR sel_rm1
.unpack_room
    JSR reset_bits_read
    TYA
    TAX
    STA bas_var_L
._clear_exits
    STA exits,X
    INX
    CPX#10
    BCC _clear_exits
    
    JSR get_one_bit
    BEQ _room_dark
    LDA #1
    STA bas_var_L
._room_dark
    LDX #0
    STX tempX
._unp_exit
    JSR get_one_bit
\  0 => no exit in that direction
    BEQ _unp_no_exit
\  10 => 4 bit room offset  11 => 8 bit absolute room
    JSR get_one_bit
    PHP
\  Save the zero flag for now. We need to get 4 bits anyway.
    JSR reset_bits_read
    JSR copy_4_bits
\  Now we have 4 bits, see if we need any more
    PLP \ 1 => we need 4 more bits
    BNE _unp_exit_long
    LDA bits_read
    BIT bits_LR+4       \  bit 3 => negative .....
    BEQ _exit_offset_pos
._exit_offset_neg
    ORA #&F8            \  ..... so set all high bits to extend sign
._exit_offset_pos
    CLC
    ADC bas_var_R
    JMP _unp_exit1
._unp_exit_long
    JSR copy_4_bits
    LDA bits_read
._unp_exit1
    LDX tempX
    STA exits,X
._unp_no_exit
    LDX tempX
    INX
    STX tempX
    CPX #10
    BCC _unp_exit       \  Repeat for all 10 exits
    LDA stream_bit      \  See if or not we need to advance
                        \  to the next byte .....
    BEQ _unp_no_adv     \  .....  No, we don't .....
    JSR advance_byte    \  .....  Yes, we do
._unp_no_adv
\  Save the stream pointer in room_desc_addr
    LDA stream_ptr+1
    STA room_desc_addr+1
    LDA stream_ptr
    STA room_desc_addr
    RTS

\  INITIALISE STREAM POINTER TO DATA FOR ROOM IN ACCUMULATOR

.sel_rm1
    LDY #&FC            \  room_table
    JSR init_strm_ptr
    LDY #0              \  Might be useful later
    STY stream_bit
    RTS

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\  SELECT AN OBJECT AND UNPACK ITS DATA
\  ON RETURN, cur_obj       => object ID
\             obj_carry     => can carry
\             obj_st        => states
\             obj_st_src    => state source
\             obj_exam      => can examine
\             obj_exam_msg  => "examine" message
\             obj_sd_length => short desc length
\             obj_sd_addr+  => "carried" description addr
\             obj_ld_addr+  => "in room" description addr

.select_obj
    STA cur_obj
.select_obj1
    JSR select_obj2
.unpack_obj
    JSR reset_bits_read
    TYA
    TAX
._clear_objdata
    STA obj_carry,X
    INX
    CPX#10
    BCC _clear_objdata
    
    \  "Can carry" is 1 bit
    
    JSR get_one_bit
    BEQ _obj_nocarry
    LDA #1
    STA obj_carry
._obj_nocarry
    LDX #0
    STX tempX
    
    \  "Has states" 

    JSR get_one_bit
    BEQ _obj_stateless  \ 0 => stateless
    JSR get_one_bit
    BEQ _obj_bistate    \ 10 => bi-state object

    \  11 => multi-state object.  State indicator = 6 bits
        
    JSR reset_bits_read
    JSR copy_4_bits
    JSR copy_2_bits
    LDA bits_read
    STA obj_st_src      \  save in state source
    LDA #2
    STA obj_st          \  mark it as multi-state
    BNE _obj_stateless  \  always branches
._obj_bistate
    LDA #1
    STA obj_st          \  mark it as bi-state
._obj_stateless

    \  Examine-ability
    
    JSR get_one_bit
    BEQ _obj_noexam     \  0 => nothing special
    JSR get_one_bit
    BNE _obj_exam_num
    \  10 => next 8 bits give long desc length
._obj_exam_text
    LDA #1
    STA obj_exam
    \  no need to reset if we are reading 8 bits in one go
    \  as we will overwrite the old contents completely
    JSR copy_4_bits
    JSR copy_4_bits
    LDA bits_read
    STA obj_ld_length
    JMP _obj_exam_next
    \  11 => following 6 bits give examine message no.
._obj_exam_num
    LDA #2
    STA obj_exam
    JSR reset_bits_read
    JSR copy_4_bits
    JSR copy_2_bits
    \  Populate the object's EXAMINE message address with the
    \  address of the wanted message
    LDY #&F8            \ msg_table
    JSR init_list_ptr
    LDA bits_read
    ASL A
    TAY
.obj_exam_cpy_ptr
    LDA (list_ptr),Y
    STA obj_em_addr
    INY
    LDA (list_ptr),Y
    STA obj_em_addr+1
    LDY #0
._obj_exam_next
    LDA stream_bit      \  See if or not we need to advance
                        \  to the next byte .....
    BEQ _obj_no_adv
    \  .....  Yes, we do
    JSR advance_byte

._obj_no_adv
    LDA (stream_ptr),Y
    STA obj_sd_length
    JSR advance_byte
    LDA stream_ptr+1
    STA obj_sd_addr+1
    STA obj_ld_addr+1
    LDA stream_ptr
    STA obj_sd_addr
    CLC
    ADC obj_sd_length
    STA obj_ld_addr
    BCC _obj_ld_addr_nc
    INC obj_ld_addr+1
._obj_ld_addr_nc
    \  see if examine type is 10
    LDA obj_exam
    CMP #1
    BNE _obj_exam_done
    CLC
    LDA obj_ld_addr
    ADC obj_ld_length
    STA obj_em_addr
    LDA obj_ld_addr+1
    ADC #0
    STA obj_em_addr+1
._obj_exam_done
    RTS
    
._obj_noexam
    \  populate the object's examine message address with the
    \  address of the stock message "nothing special"
    
    LDY #&FA            \ smsg_table
    JSR init_list_ptr
    LDY #2 * SM_EXAM_0SPEC
    BNE obj_exam_cpy_ptr

\  INITIALISE STREAM POINTER TO DATA FOR OBJECT IN ACCUMULATOR

.select_obj2
    LDY #&FE            \ obj_table
    JSR init_strm_ptr
    LDY #0
    STY stream_bit
    RTS

\  UPDATE A STATEFUL OBJECT ACCORDING TO ITS STATE
\  READS APPROPRIATE GAME STATE REGISTER, AND MAYBE UNPACKS A
\  SURROGATE OBJECT'S DESCRIPTIONS AND EXAMINE MESSAGE

.update_obj_state
    LDA cur_obj
    STA orig_obj
    LDA obj_st
    BEQ _uos_stateless
    CMP #2
    BCC _uos_bistate

\  MULTIPLE STATES; obj_st_src SPECIFIES A STATUS BYTE WHICH GIVES
\  THE SURROGATE OBJECT, IF ANY

._uos_polystate
    LDX obj_st_src      \  get relevant state byte
    LDA state_bytes, X
    BEQ _uos_stateless  \  do nothing if it is zero
    JMP select_obj1

\  TWO STATES; THE STATUS BIT CORRESPONDING TO THE OBJECT'S ID SAYS
\  WHETHER OR NOT TO USE THE NEXT OBJECT AS A SURROGATE

._uos_bistate
    LDA orig_obj
    JSR real_get_state_bit
    BEQ _uos_stateless
    LDX orig_obj        \  get original object ID
    INX                 \  increase it
    TXA
    JMP select_obj1
    
\  STATELESS  (OR IN DEFAULT STATE)

._uos_stateless
    RTS


\  RESET THE POSITION ON THE TREE / BITS READ
\  ALSO MAKE SURE Y=0 FOR THE BIT STREAM EXTRACTION

.reset_tree_pos
.reset_bits_read
    LDY #0  \ will be useful later
    STY tree_pos
    RTS

\  EXTRACT BITS FROM THE STREAM AND ROLL LEFT INTO THE
\  DESTINATION BYTE

.copy_4_bits
    JSR copy_2_bits
.copy_2_bits
    JSR copy_one_bit
    
\  EXTRACT A SINGLE BIT FROM THE STREAM AND ROLL LEFT
\  INTO THE DESTINATION BYTE

.copy_one_bit
    JSR get_one_bit
    BEQ _copy_zero
._copy_one
    SEC
    ROL tree_pos
    RTS
._copy_zero
    ASL tree_pos
    RTS

\  EXTRACT A SINGLE BIT FROM THE COMPRESSED STREAM
\  THIS IS USED BOTH IN DESCENDING TREE AND COPYING BITS
\  ON ENTRY;  EXPECTS Y=0
\             UPDATES [stream_ptr] AND [stream_bit]
\  ON RETURN; X=[tree_pos] FOR DESCENDING TREE
\             Z=1 IF BIT IS ZERO
\  WE NEED TO SET X FIRST BECAUSE Z IS SO FRAGILE.

.get_one_bit
    LDA (stream_ptr),Y
    LDX stream_bit
    AND bits_LR,X
    PHP \ save the zero flag
    INX
    STX stream_bit
    CPX #8
    BCC _getbit1
    LDX #0
    STX stream_bit
    INC stream_ptr
    BNE _getbit1
    INC stream_ptr+1
._getbit1
    LDX tree_pos \ current position on tree
    PLP \ restore the saved zero flag
    RTS

\  ADVANCE TO FIRST BIT OF NEXT BYTE IN STREAM

.advance_byte
    LDX #0
    STX stream_bit
    INC stream_ptr
    BNE _advbyte1
    INC stream_ptr+1
._advbyte1
    RTS

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

.space
    LDA #32
    JMP osasci

\  OSWRCH REPLACEMENT
\  PRINTABLE CHARACTERS ARE STORED IN A BUFFER, WHICH GETS FLUSHED IF IT
\  REACHES A FULL LINE OR A SPACE OR CONTROL CHARACTER IS ENCOUNTERED.
\  IF THE WORD IN THE BUFFER WILL FIT ON SCREEN, IT IS DISPLAYED AND THEN
\    THE CONTROL CHARACTER IS PASSED TO THE ORIGINAL WRCH ROUTINE.
\  IF THE WORD IN THE BUFFER IS TOO LONG TO FIT ON SCREEN, A NEW LINE
\    IS STARTED AND THEN THE WORD DISPLAYED AS ABOVE.
\  IF THE WORD IN THE BUFFER *ONLY JUST* FITS, IT IS PRINTED WITH *NO*
\    FOLLOWING SPACE AND THE CURSOR WILL AUTOMATICALLY BE AT THE
\    BEGINNING OF THE NEXT LINE.

.newwrch
    STA tempA
    TYA
    PHA
    TXA
    PHA    
    LDA tempA
    CMP #33
    BCC _nwc_is_eow
._nwc_printable
    LDX wbuf_ptr
    STA wordbuf,X
    INX
    STX wbuf_ptr
    CPX #LWIDTH
    BCS _nwc_buffer_full
    BCC restore
\  If the word buffer is full, there is by definition no way we can fit
\  it all onto one line; so just dump it out as-is.
._nwc_buffer_full
    JSR _nwc_dump_buf
    LDX #0
    STX wbuf_ptr
.restore
    PLA
    TAX
    PLA
    TAY
    LDA tempA
    RTS

._nwc_dump_buf           \  Dump out word buffer
    LDX #0
._dwb1
    LDA wordbuf,X
    JSR orig_wrch
    INX
    CPX wbuf_ptr
    BCC _dwb1
    RTS

._nwc_is_eow            \  END OF WORD
    LDX wbuf_ptr        \  See if buffer is empty .....
    BEQ _nwc_dumped     \  ..... if so, don't try to dump it
._nwc_not_empty
    \  See if the word will fit on the screen
    CLC
    LDA scr_width
    ADC wbuf_ptr
    CMP #LWIDTH
    BEQ _nwc_just_fits  \  fits, but no room for space
    BCC _nwc_fits    
    \  start a new line for the word
    \JSR osnewl
    LDA #10
    JSR orig_wrch
    LDA #13
    JSR orig_wrch
    LDA #0
    STA scr_width		\  back to beginning of line
._nwc_fits
    JSR _nwc_dump_buf
._nwc_dumped
    LDA tempA
    BEQ _nwc_not_eol    \  CHR$(0) is non-spacing word break
    CMP #13
    BEQ _nwc_is_CR
    \  treat as space
    LDA wbuf_ptr
    SEC                 \  to account for the space
    ADC scr_width
    STA scr_width
    CMP #LWIDTH         \  see if we have hit end of line
    BCC _nwc_not_eol
    LDA #0              \  set line position to beginning
    STA scr_width
._nwc_not_eol
    LDA #0
    STA wbuf_ptr
    LDA tempA
    JSR orig_wrch
    JMP restore
._nwc_just_fits
    JSR _nwc_dump_buf   \  taking us to end of line
    BCS _nwc_start_line \  we know C=1 here
._nwc_is_CR
    JSR orig_wrch
._nwc_start_line
    LDA #0
    STA scr_width
    STA wbuf_ptr
    BEQ restore

\  DISPLAY UNCOMPRESSED INLINE TEXT

.say
    PLA
    STA stream_ptr
    PLA
    STA stream_ptr+1
    LDY#1
._say1
    JSR _say_XY1
._say2
    CLC
    TYA
    ADC stream_ptr
    STA stream_ptr
    LDA stream_ptr+1
    ADC #0
    PHA
    LDA stream_ptr
    PHA
    RTS

\  DISPLAY UNCOMPRESSED TEXT POINTED TO BY XY
\  ON ENTRY  X => LOW BYTE OF ADDRESS OF TEXT
\            Y => HIGHT BYTE OF ADDRESS

.say_XY
    STX stream_ptr
    STY stream_ptr+1
    LDY #0
._say_XY1
    LDA (stream_ptr),Y
    CMP #32
    BCC _say_XY2
    JSR osasci
    INY
    BNE _say_XY1
._say_XY2
    RTS
    
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\  TABLE OF BIT VALUES, IN ORDER LEFT TO RIGHT
.bits_LR
    EQUB &80
    EQUB &40
    EQUB &20
    EQUB &10
    EQUB &08
    EQUB &04
    EQUB &02
    EQUB &01

.osfile_cb
    EQUW _def_fn
    EQUD state_bits
    EQUD state_bits
    EQUD state_bits
    EQUD state_bits + &100
._cb_addrs
    EQUD state_bits
    EQUD state_bits
    EQUD state_bits
    EQUD state_bits + &100
._def_fn
    EQUS "S.BDSAVE"
    EQUB 13
    
ALIGN &40

.cur_room
    EQUB 0
.light
    EQUB 0
.exits
    EQUD 0:EQUD 0:EQUW 0
.prev_rm
    EQUB 0
.room_desc_addr
    EQUW 0

.cur_obj
    EQUB 0
.obj_carry
    EQUB 0
.obj_st
    EQUB 0
.obj_st_src
    EQUB 0
.obj_exam
    EQUB 0
.obj_exam_msg
    EQUB 0
.obj_sd_length
    EQUB 0
.obj_ld_length
    EQUB 0
.obj_sd_addr
    EQUW 0
.obj_ld_addr
    EQUW 0
.obj_em_addr
    EQUW 0
.orig_obj
    EQUB 0

\  DISPLAY WRAPPED TEXT FROM LOCATION GIVEN BY I%
    
.real_wrap_txt
    LDX bas_var_I
    LDY bas_var_I+1
    JMP say_XY

\  A JMP INSTRUCTION WHICH WILL BE OVERWRITTEN WITH THE ORIGINAL
\  VALUE FROM WRCHV AT &20E WHEN wrap_on IS CALLED.  THIS IS USED WHEN
\  THE CODE AT newwrch NEEDS TO PRINT SOME ACTUAL CHARACTERS.
\
\  (YOU WILL HAVE TO CHANGE THIS TO USE AN INDIRECT JMP(), IF YOU EVER
\   MAKE A VERSION OF THIS TO RUN FROM SIDEWAYS ROM ..... Julez)
\
\  This starts out with &FFEE to give sensible behaviour if newwrch is
\  called before wrap_on has been called.

.orig_wrch
    JMP &FFEE

\  ENABLE TEXT WRAPPING
\
\  If WRCHV contains the address of our own subroutine then skip copying
\  its contents into orig_wrch+1 and orig_wrch+2
\  This makes sure not to create an infinite loop by redirecting back to
\  ourselves when we have actually to print anything.

.real_wrap_on
    LDX &20E            \ low byte of WRCHV
    LDY &20F            \ high byte of WRCHV
    CPX #newwrch MOD256
    BNE _won_1
    CPY #newwrch DIV256
    BEQ _won_no_save
._won_1
    STX orig_wrch+1     \ second byte of JMP instruction
    STY orig_wrch+2     \ third byte of JMP
._won_no_save
    LDX #newwrch MOD256
    LDY #newwrch DIV256
    JMP _wrap_save_wrchv
 
 \  DISABLE TEXT WRAPPING
 \
 \  If orig_wrch+1 contains &EE and 
 
.real_wrap_off
    LDX orig_wrch+1
    LDY orig_wrch+2
    CPX #&EE
    BNE _wrap_save_wrchv
    CPY #&FF
    BEQ _wrap_no_save
._wrap_save_wrchv
    STX &20E
    STY &20F
._wrap_no_save
    RTS
    
._end_of_code

ALIGN &100
CLEAR _end_of_code, P%
ORG P%-66               \  22 * JMP xxxx => 66 bytes
.shift_on
    JMP real_shift_on
.wrap_on
    JMP real_wrap_on
.wrap_off
    JMP real_wrap_off
.wrap_txt
    JMP real_wrap_txt
.obj_short_desc
    JMP real_obj_short_desc
.get_visited
    JMP real_get_visited
.get_state_bit
    JMP real_get_state_bit
.clear_state_bit
    JMP real_clear_state_bit
.set_state_bit
    JMP real_set_state_bit
.select_msg
    JMP real_select_msg
.select_sysmsg
    JMP real_select_sysmsg
.test_avail
    JMP real_test_avail
.test_avail_X
    JMP real_test_avail_X
.init_game
    JMP real_init_game
.select_room
    JMP real_select_room
.art_light
    JMP real_art_light
.disp_desc
    JMP real_disp_desc
.disp_exits
    JMP get_exits
.list_objects
    JMP real_list_objects
.get_cmd
    JMP real_get_cmd
.action_cmd
    JMP real_action_cmd
.inventory
    JMP real_inventory

._code_end

\  ORG IS EQUIVALENT TO SETTING P%, ON A REAL BEEB

ORG game_data

INCLUDE "bobajob_st_data.6502"

tables0 = tree AND &FF00

SAVE "M.ABENGIN", _code_begin, _code_end, _rts
SAVE "D.BOBAJOB", game_data, _game_data_end

PRINT "Code length =", ~_code_end-_code_begin
PRINT "Data length =",~_game_data_end - game_data
PRINT ""
PRINT "loc =",~object_loc
PRINT ""
PRINT "tree =", ~tree
PRINT "tables =", ~tables
PRINT ""
PRINT "newwrch =", ~newwrch
\PRINT "newnewl =", ~newnewl
\PRINT ""

\\  DEDICATED TO THE PUBLIC DOMAIN 2021 BY JULIE KIRSTY LOUISE MONTOYA
\\  <bluerizlagirl@gmail.com>  NO RIGHTS RESERVED
\\
\\  USE IT - ABUSE IT - ENJOY IT - DESTROY IT - STUDY IT - SHARE IT - ADAPT IT
\\
